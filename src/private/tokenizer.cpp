/* Copyright (c) 2014-2015, The Nuria Project
 * The NuriaProject Framework is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 * 
 * The NuriaProject Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with The NuriaProject Framework.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#include "tokenizer.hpp"

#include <nuria/tokenizer.hpp>
#include <ctype.h>
#include <QVector>

// As generated by LEMON from grammar/twig.y
#include "../grammar/twig.h"

static const QString g_commandBlockRule = QStringLiteral("command");

namespace Nuria {
class Template::TokenizerPrivate {
public:
	
	int position = 0;
	QVector< Token > tokens;
	Nuria::Tokenizer *tokenizer;
	
	// 
	QByteArray commandBegin = QByteArrayLiteral("{%");
	QByteArray commandEnd = QByteArrayLiteral("%}");
	
	QByteArray expansionBegin = QByteArrayLiteral("{{");
	QByteArray expansionEnd = QByteArrayLiteral("}}");
	
	QByteArray commentBegin = QByteArrayLiteral("{#");
	QByteArray commentEnd = QByteArrayLiteral("#}");
	
};
}

// Synchronous with Nuria::Template::Token::Type
enum FindState {
	FoundEnd = 0,
	FoundCommand = 1,
	FoundExpansion = 2,
	FoundComment = 3
};

// Forward declarations
static const char *findEndOfString (const char *from, Nuria::Template::Location &loc);
static QByteArray parseStringLiteral (QByteArray literal);

static bool tokenizeString (Nuria::Token &tok, Nuria::Tokenizer *tokenizer) {
	QByteArray data = tokenizer->tokenizeData ();
	const char *raw = data.constData ();
	
	// Find end of string
	int pos = tokenizer->currentPosition () - 1;
	Nuria::Template::Location loc (tokenizer->currentRow (), tokenizer->currentColumn ());
	const char *end = findEndOfString (raw + pos, loc);
	
	// Update tokenizer position
	int endPos = end - raw;
	tokenizer->setPosition (endPos, loc.column - 1, loc.row);
	
	// Sanity check for a string not ended
	if (endPos > data.length ()) {
		return false;
	}
	
	// 
	QByteArray literal = parseStringLiteral (QByteArray::fromRawData (raw + pos, endPos - pos));
	tok.value = QString::fromUtf8 (literal);
	return true;
}

static bool convertNumber (Nuria::Token &tok, Nuria::Tokenizer *) {
	QByteArray v = tok.value.toByteArray ();
	
	bool ok = false;
	if (v.contains ('.') || v.contains ('e')) {
		tok.value = v.toDouble (&ok);
	} else {
		tok.value = v.toInt (&ok);
		tok.tokenId = TOK_INTEGER;
	}
	
	return ok;
}

static bool convertBool (Nuria::Token &tok, Nuria::Tokenizer *) {
	tok.value = (tok.tokenId == TOK_TRUE);
	return true;
}

static void addConversionHandlers (Nuria::TokenizerRules &rules) {
	rules.setTokenAction (TOK_NUMBER, convertNumber);
	rules.setTokenAction (TOK_STRING, tokenizeString);
	rules.setTokenAction (TOK_TRUE, convertBool);
	rules.setTokenAction (TOK_FALSE, convertBool);
	
}

static Nuria::TokenizerRules basicTokenizerRules () {
	Nuria::TokenizerRules rules;
	addConversionHandlers (rules);
	
	// For inline-if in for loops
	rules.addRegexToken (TOK_IF_BEGIN, QByteArrayLiteral("if\\b"));
	
	rules.addRegexToken (TOK_STARTS, QByteArrayLiteral("starts\\b"));
	rules.addRegexToken (TOK_ENDS, QByteArrayLiteral("ends\\b"));
	rules.addRegexToken (TOK_WITH, QByteArrayLiteral("with\\b"));
	rules.addRegexToken (TOK_MATCHES, QByteArrayLiteral("matches\\b"));
	rules.addRegexToken (TOK_DEFINED, QByteArrayLiteral("defined\\b"));
	rules.addRegexToken (TOK_NULL, QByteArrayLiteral("null\\b"));
	rules.addRegexToken (TOK_DIVISIBLE, QByteArrayLiteral("divisible\\b"));
	rules.addRegexToken (TOK_ITERABLE, QByteArrayLiteral("iterable\\b"));
	rules.addRegexToken (TOK_EVEN, QByteArrayLiteral("even\\b"));
	rules.addRegexToken (TOK_ODD, QByteArrayLiteral("odd\\b"));
	rules.addRegexToken (TOK_EMPTY, QByteArrayLiteral("empty\\b"));
	rules.addRegexToken (TOK_IS, QByteArrayLiteral("is\\b"));
	rules.addRegexToken (TOK_BY, QByteArrayLiteral("by\\b"));
	
	rules.addRegexToken (TOK_AND, QByteArrayLiteral("and\\b"));
	rules.addRegexToken (TOK_OR, QByteArrayLiteral("or\\b"));
	rules.addRegexToken (TOK_IN, QByteArrayLiteral("in\\b"));
	rules.addRegexToken (TOK_NOT, QByteArrayLiteral("not\\b"));
	
	// Types
	rules.addRegexToken (TOK_NUMBER, QByteArrayLiteral("[0-9]+(?:\\.[0-9]*)?(?:e[0-9]+)?"));
	rules.addRegexToken (TOK_STRING, QByteArrayLiteral("[\"']")); // Strings are handled in the token handler
	rules.addRegexToken (TOK_TRUE, QByteArrayLiteral("true\\b"));
	rules.addRegexToken (TOK_FALSE, QByteArrayLiteral("false\\b"));
	rules.addRegexToken (TOK_SYMBOL, QByteArrayLiteral("[a-zA-Z_][a-zA-Z0-9_]*"));
	
	// String tokens
	rules.addStringToken (TOK_EQUALS, QByteArrayLiteral("=="));
	rules.addStringToken (TOK_NOT_EQUALS, QByteArrayLiteral("!="));
	rules.addStringToken (TOK_NOT, QByteArrayLiteral("!"));
	rules.addStringToken (TOK_LESS_EQUAL, QByteArrayLiteral("<="));
	rules.addStringToken (TOK_LESS, QByteArrayLiteral("<"));
	rules.addStringToken (TOK_GREATER_EQUAL, QByteArrayLiteral(">="));
	rules.addStringToken (TOK_GREATER, QByteArrayLiteral(">"));
	rules.addStringToken (TOK_AND, QByteArrayLiteral("&&"));
	rules.addStringToken (TOK_OR, QByteArrayLiteral("||"));
	
	rules.addStringToken (TOK_ASSIGN, QByteArrayLiteral("="));
	
	rules.addStringToken (TOK_PLUS, QByteArrayLiteral("+"));
	rules.addStringToken (TOK_MINUS, QByteArrayLiteral("-"));
	rules.addStringToken (TOK_POWER, QByteArrayLiteral("**"));
	rules.addStringToken (TOK_MULTIPLY, QByteArrayLiteral("*"));
	rules.addStringToken (TOK_ROUND, QByteArrayLiteral("//"));
	rules.addStringToken (TOK_DIVIDE, QByteArrayLiteral("/"));
	rules.addStringToken (TOK_MODULO, QByteArrayLiteral("%"));
	rules.addStringToken (TOK_CONCAT, QByteArrayLiteral("~"));
	
	rules.addStringToken (TOK_COMMA, QByteArrayLiteral(","));
	rules.addStringToken (TOK_COLON, QByteArrayLiteral(":"));
	rules.addStringToken (TOK_PERIOD_PERIOD, QByteArrayLiteral(".."));
	rules.addStringToken (TOK_PERIOD, QByteArrayLiteral("."));
	rules.addStringToken (TOK_PIPE, QByteArrayLiteral("|"));
	
	rules.addStringToken (TOK_PAREN_OPEN, QByteArrayLiteral("("));
	rules.addStringToken (TOK_PAREN_CLOSE, QByteArrayLiteral(")"));
	rules.addStringToken (TOK_ARRAY_BEGIN, QByteArrayLiteral("["));
	rules.addStringToken (TOK_ARRAY_END, QByteArrayLiteral("]"));
	rules.addStringToken (TOK_OBJECT_BEGIN, QByteArrayLiteral("{"));
	rules.addStringToken (TOK_OBJECT_END, QByteArrayLiteral("}"));
	rules.addStringToken (TOK_QUESTION_COLON, QByteArrayLiteral("?:"));
	rules.addStringToken (TOK_QUESTION, QByteArrayLiteral("?"));
	
	return rules;
}

static Nuria::TokenizerRules commandPrefixRules () {
	Nuria::TokenizerRules rules;
	
	rules.addStringToken (TOK_SET, QByteArrayLiteral("set"));
	rules.addStringToken (TOK_EXTENDS, QByteArrayLiteral("extends"));
	rules.addStringToken (TOK_INCLUDE, QByteArrayLiteral("include"));
	rules.addStringToken (TOK_EMBED_BEGIN, QByteArrayLiteral("embed"));
	rules.addStringToken (TOK_EMBED_END, QByteArrayLiteral("endembed"));
	rules.addStringToken (TOK_FILTER_BEGIN, QByteArrayLiteral("filter"));
	rules.addStringToken (TOK_FILTER_END, QByteArrayLiteral("endfilter"));
	rules.addStringToken (TOK_SPACELESS_BEGIN, QByteArrayLiteral("spaceless"));
	rules.addStringToken (TOK_SPACELESS_END, QByteArrayLiteral("endspaceless"));
	rules.addStringToken (TOK_AUTOESCAPE_BEGIN, QByteArrayLiteral("autoescape"));
	rules.addStringToken (TOK_AUTOESCAPE_END, QByteArrayLiteral("endautoescape"));
	rules.addStringToken (TOK_BLOCK_BEGIN, QByteArrayLiteral("block"));
	rules.addStringToken (TOK_BLOCK_END, QByteArrayLiteral("endblock"));
	rules.addStringToken (TOK_FOR_BEGIN, QByteArrayLiteral("for"));
	rules.addStringToken (TOK_FOR_END, QByteArrayLiteral("endfor"));
	rules.addStringToken (TOK_IF_BEGIN, QByteArrayLiteral("if"));
	rules.addStringToken (TOK_IF_END, QByteArrayLiteral("endif"));
	rules.addStringToken (TOK_ELSE, QByteArrayLiteral("else"));
	
	return rules;
}

static void setUpTokenizer (Nuria::Tokenizer *tokenizer) {
	tokenizer->setDefaultTokenizerRules (basicTokenizerRules ());
	tokenizer->addTokenizerRules (g_commandBlockRule, commandPrefixRules ());
	
}

Nuria::Template::Tokenizer::Tokenizer (QObject *parent)
        : QObject (parent), d_ptr (new Template::TokenizerPrivate)
{
	
	this->d_ptr->tokenizer = new Nuria::Tokenizer (this);
	setUpTokenizer (this->d_ptr->tokenizer);
	
}

Nuria::Template::Tokenizer::~Tokenizer () {
	delete this->d_ptr;
}

static inline void advanceLocation (Nuria::Template::Location &loc, char cur) {
	loc.column++;
	if (cur == '\n') {
	        loc.column = 0;
	        loc.row++;
	}
	
}

static FindState findNext (int &pos, Nuria::Template::Location &loc, const char *data,
                           Nuria::Template::TokenizerPrivate *d) {
	
	while (data[pos]) {
		if (!::memcmp (d->commandBegin.constData (), data + pos, d->commandBegin.length ())) {
			return FoundCommand;
		}
		
		if (!::memcmp (d->expansionBegin.constData (), data + pos, d->expansionBegin.length ())) {
			return FoundExpansion;
		}
		
		if (!::memcmp (d->commentBegin.constData (), data + pos, d->commentBegin.length ())) {
			return FoundComment;
		}
		
		// Update location
		advanceLocation (loc, data[pos]);
		pos++;
	}
	
	return FoundEnd;
}

static const char *findEndOfString (const char *from, Nuria::Template::Location &loc) {
	char endMarker = *from;
	const char *end;
	
	// Skip initial quote
	advanceLocation (loc, '"');
	for (end = from + 1; *end && *end != endMarker; end++) {
		advanceLocation (loc, *end);
		if (*end == '\\') {
			end++;
			advanceLocation (loc, *end);
		}
		
	}
	
	// Skip trailing quote
	advanceLocation (loc, '"');
	return end + 1;
}

static int findEnd (int pos, Nuria::Template::Location &loc, const char *data, const QByteArray &marker) {
	const char *markerRaw = marker.constData ();
	int len = marker.length ();
	const char *start = data;
	data += pos;
	
	for (; *data; data++) {
		if (*data == '"' || *data == '\'') {
			data = findEndOfString (data, loc);
		} else if (!::memcmp (data, markerRaw, len)) {
			return data - start;
		} else {
			advanceLocation (loc, *data);
		}
		
	}
	
	// Not found.
	return -1;
}

static QByteArray beginTokenFor (FindState state, Nuria::Template::TokenizerPrivate *d) {
	switch (state) {
	default: QByteArray ();
	case FoundCommand: return d->commandBegin;
	case FoundExpansion: return d->expansionBegin;
	case FoundComment: return d->commentBegin;
	}
	
}

static QByteArray endTokenFor (FindState state, Nuria::Template::TokenizerPrivate *d) {
	switch (state) {
	default: QByteArray ();
	case FoundCommand: return d->commandEnd;
	case FoundExpansion: return d->expansionEnd;
	case FoundComment: return d->commentEnd;
	}
	
}

static void createAndPushToken (FindState state, const char *data, int begin, int end,
                                Nuria::Template::Location loc,
                                Nuria::Template::TokenizerPrivate *d) {
	QByteArray text (data + begin, end - begin);
	int type = state;
	
	d->tokens.append (Nuria::Token (type, loc.row, loc.column, text));
	
}

static void createAndPushTextToken (const char *data, int begin, int end,
                                    Nuria::Template::Location loc,
                                    Nuria::Template::TokenizerPrivate *d) {
	if (begin >= end) {
		return;
	}
	
	// 
	QString text = QString::fromUtf8 (data + begin, end - begin);
	d->tokens.append (Nuria::Token (TOK_TEXT, loc.row, loc.column, text));
}

void Nuria::Template::Tokenizer::read (const QByteArray &data) {
	reset ();
	
	// 
	if (data.isEmpty ()) {
		return;
	}
	
	// 
	parseFirstStage (data);
	tokenizeExpansionsAndCommands ();
	
}

QVector< Nuria::Token > Nuria::Template::Tokenizer::allTokens () const {
	return this->d_ptr->tokens;
}

Nuria::Token Nuria::Template::Tokenizer::nextToken () {
	Token tok = this->d_ptr->tokens.at (this->d_ptr->position);
	this->d_ptr->position++;
	return tok;
}

int Nuria::Template::Tokenizer::pos () const {
	return this->d_ptr->position;
}

bool Nuria::Template::Tokenizer::atEnd () const {
	return (this->d_ptr->position >= this->d_ptr->tokens.length ());
}

void Nuria::Template::Tokenizer::reset () {
	this->d_ptr->tokens.clear ();
	this->d_ptr->position = 0;
}

void Nuria::Template::Tokenizer::parseFirstStage (const QByteArray &data) {
	const char *raw = data.constData ();
	FindState state;
	Template::Location begin;
	Template::Location loc;
	int previous = 0;
	int pos = 0;
	
	// 
	while ((state = findNext (pos, loc, raw, this->d_ptr)) != FoundEnd) {
		createAndPushTextToken (raw, previous, pos, begin, this->d_ptr);
		
		// 
		begin = loc;
		QByteArray marker = endTokenFor (state, this->d_ptr);
		int end = findEnd (pos, loc, raw, marker);
		
		// 
		pos += beginTokenFor (state, this->d_ptr).length ();
		createAndPushToken (state, raw, pos, end, begin, this->d_ptr);
		
		// Next.
		pos = end + marker.length ();
		previous = pos;
		loc.column += marker.length ();
		begin = loc;
		
	}
	
	// Append last bits of text
	createAndPushTextToken (raw, previous, data.length (), begin, this->d_ptr);
	
}

static inline char stringLiteralEscapeChar (char name) {
	switch (name) {
	default: return name;
	case 'r': return '\r';
	case 'n': return '\n';
	case 't': return '\t';
	case 'v': return '\v';
	case 'b': return '\b';
	case '\'': return '\'';
	case '"': return '"';
	case '\\': return '\\';
	}
}

static QByteArray parseStringLiteral (QByteArray literal) {
	int len = literal.length ();
	
	// Find and evaluate escaped characters
	for (int i = 0; i < len - 1; i++) {
		if (literal.at (i) == '\\') {
			len--;
			char replaceWith = stringLiteralEscapeChar (literal.at (i + 1));
			literal.replace (i, 2, &replaceWith, 1);
		}
		
	}
	
	// Remove trailing quotation mark
	literal.chop (1);
	return literal;
}

bool Nuria::Template::Tokenizer::hasTrimTokenStart (const QByteArray &code) {
	if (!code.isEmpty () && code.at (0) == '-') {
		return true;
	}
	
	return false;
}

bool Nuria::Template::Tokenizer::hasTrimTokenEnd (const QByteArray &code) {
	if (!code.isEmpty () && code.at (code.length () - 1) == '-') {
		return true;
	}
	
	return false;
}

bool Nuria::Template::Tokenizer::tokenizeAndPush (QByteArray code, Location &loc, bool switchToDefault) {
	if (code.isEmpty ()) {
		return true;
	}
	
	// Trimmer
	Location base = loc;
	bool pushEndTrimmer = hasTrimTokenEnd (code);
	
	if (pushEndTrimmer) {
		code.chop (1);
	}
	
	if (hasTrimTokenStart (code)) {
		base.column++;
		code = code.mid (1);
		this->d_ptr->tokens.append (Token (TOK_TRIM, base.row, base.column));
	}
	
	// 
	this->d_ptr->tokenizer->tokenize (code);
	
	// Read 'code'
	while (!this->d_ptr->tokenizer->atEnd ()) {
		
		// Tokenize and error check
		Token tok = this->d_ptr->tokenizer->nextToken ();
		if (this->d_ptr->tokenizer->hasError ()) {
			break;
		}
		
		// Success. Calculate location
		tok.column += base.column;
		tok.row += base.row;
		
		// Store if this token is not ignored
		if (tok.tokenId >= 0) {
			this->d_ptr->tokens.append (tok);
		}
		
		// Switch back to default rule-set
		if (switchToDefault) {
			switchToDefault = false;
			this->d_ptr->tokenizer->setCurrentTokenizerRules (QString ());
		}
		
	}
	
	// Adjust location
	loc.column += this->d_ptr->tokenizer->currentColumn ();
	loc.row += this->d_ptr->tokenizer->currentRow ();
	
	// Push trimmer?
	if (pushEndTrimmer) {
		this->d_ptr->tokens.append (Token (TOK_TRIM, base.row, base.column));
		loc.column++;
	}
	
	// Done.
	return !this->d_ptr->tokenizer->hasError ();
}

void Nuria::Template::Tokenizer::pushTextToken (Token token, int previousTokId) {
	QString str = token.value.toString ();
	
	if (previousTokId == FoundCommand || previousTokId == FoundComment) {
		token.value.clear (); // We should now own the value. Avoids copies
		
		// Remove leading new-line character if any
		if (str.startsWith ('\n')) {
			str = str.mid (1);
		}
		
		// Re-insert value
		token.value = str;
	}
	
	// Store if not empty
	if (!str.isEmpty ()) {
		this->d_ptr->tokens.append (token);
	}
	
}

void Nuria::Template::Tokenizer::pushComment (Token token) {
	QByteArray code = token.value.toByteArray ();
	bool trimStart = hasTrimTokenStart (code);
	bool trimEnd = hasTrimTokenEnd (code);
	
	// Push token
	if (trimStart && trimEnd) {
		token.tokenId = TOK_COMMENT_LR;
	} else if (trimStart) {
		token.tokenId = TOK_COMMENT_L;
	} else if (trimEnd) {
		token.tokenId = TOK_COMMENT_R;
	} else {
		return;
	}
	
	// Push comment token
	this->d_ptr->tokens.append (token);
}

bool Nuria::Template::Tokenizer::tokenizeExpansionsAndCommands () {
	QVector< Token > tokens;
	tokens.swap (this->d_ptr->tokens);
	
	// 
	int prevTokenId = -1;
	for (int i = 0; i < tokens.length (); i++) {
		const Token &tok = tokens.at (i);
		Location loc (tok.row, tok.column);
		
		switch (tok.tokenId) {
		case TOK_TEXT:
			pushTextToken (tok, prevTokenId);
			
			break;
		case FoundCommand:
			removeTrailingEmptyLineInLastTextToken ();
			this->d_ptr->tokenizer->setCurrentTokenizerRules (g_commandBlockRule);
			
			this->d_ptr->tokens.append (Token (TOK_COMMAND_BEGIN, loc.row, loc.column));
			loc.column += this->d_ptr->commandBegin.length ();
			tokenizeAndPush (tok.value.toByteArray (), loc, true);
			this->d_ptr->tokens.append (Token (TOK_COMMAND_END, loc.row, loc.column));
			
			break;
		case FoundExpansion:
			this->d_ptr->tokens.append (Token (TOK_EXPANSION_BEGIN, loc.row, loc.column));
			loc.column += this->d_ptr->expansionBegin.length ();
			tokenizeAndPush (tok.value.toByteArray (), loc, false);
			this->d_ptr->tokens.append (Token (TOK_EXPANSION_END, loc.row, loc.column));
			
			break;
		case FoundComment:
			removeTrailingEmptyLineInLastTextToken ();
			pushComment (tok);
			break;
		default: return false;
		}
		
		// 
		prevTokenId = tok.tokenId;
	}
	
	// 
	return true;
}

void Nuria::Template::Tokenizer::removeTrailingEmptyLineInLastTextToken () {
	if (this->d_ptr->tokens.isEmpty () || this->d_ptr->tokens.last ().tokenId != TOK_TEXT) {
		return;
	}
	
	// Obtain string
	Token &tok = this->d_ptr->tokens.last ();
	QString str = tok.value.toString ();
	tok.value.clear ();
	
	// Find trailing empty line
	int i;
	for (i = str.length () - 1;
	     i >= 0 && str.at (i).isSpace () && str.at (i) != QLatin1Char ('\n');
	     i--);
	
	// Remove
	if (i > 0 && str.at (i) == QLatin1Char ('\n')) {
		str.chop (str.length () - i);
	} else if (i == 0 && str.at (i).isSpace ()) { // String is completely empty
		str.clear ();
	}
	
	// Store
	tok.value = str;
}
